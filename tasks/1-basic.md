# Блок "Общий обзор языка"

Данный блок содержит материалы по общим основам языка, ссылки на необходимые материалы, которые нужно прочитать, упражнения и вопросы для закрепления. Рекомендуем внимательно читать указанные материалы, переходя по ссылка или находя указанные главы в литературе, запускать примеры, описанные в учебных материалах, а после ответить на вопросы для закрепления и выполнить задания.

## Работа с Erlang shell
Прежде, чем приступить к обучению, Вам необходимо освоиться с оболочкой Erlang (интерпретатором), изучить базовый список комманд. Предполагается, что вы работаете под \*nix-совместимой операционной системой, на которой уже установлен Erlang, и для запуска оболочки Вам необходимо открыть терминал и ввести команду `erl`.
### Материалы для изучения:
 - [Basic erlang shell](http://learnyousomeerlang.com/starting-out)
 - [Shell commands](http://stefanalfbo.github.io/blog/2013/04/23/erlang-shell-cheat-sheet/)
 - [Стандартная документация по erlang shell](http://erlang.org/doc/man/shell.html)

### Вопросы:
 - Внимательно изучите вывод комманды help().
 - С помощью какой команды можно посмотреть историю?
 - С помощью какой команды можно посмотреть статистику потребления памяти?
 - Как узнать текущий uptime запущенной оболочки?
 - Как грамотно завершить работу оболочки?

## Выражения Erlang, переменные, типы данных.
В данном разделе вы узнаете, что такое выражения, сопоставление с образцом, одиночные присваивания(связывания).

### Материалы для изучения:
 - Joe Armstrong, Programming in Erlang, chapter 2, pages 24 - 42.
 - [Числа, списки, кортежи, атомы, бинарные строки](http://learnyousomeerlang.com/starting-out-for-real).
 - [Хеш-таблицы(словари)](http://learnyousomeerlang.com/maps)
 - [Записи и другие структуры данных](http://learnyousomeerlang.com/a-short-visit-to-common-data-structures).

### Упражнения
#### 1.1. Простые выражения. Введите в оболочку Erlang следующие выражения и объясните результат.
 - `B = 1.`
 - `1 = B.`
 - `1 = C.`
 - `C = 1.`
 - `C = B.`
 - `A = F = D = B.` (Что в данном случае происходит с переменными A, F, D при наличи уже связанной переменной B?)

#### 1.2. Сопоставление с образцом.
 - Объясните, почему выражение `Path = "/bar/foo", Bar ++ "/foo" = Path` не может быть вычислено интерпретатором и порождает ошибку?
 - А сработает ли следующее выражение: `"/bar/" ++ Foo = Path.`? Что является его результатом?
 - Каков результат следующего выражения?  
```erlang
Person = #{name => "Mike", surname => "Williams", phone  => [1,2,3,4]}.
#{
    name := Name,
    surname := Name,
    phone := Phone
} = Person.
```

#### 1.3. Сравнение
На всех типах данных определены операции сравнения, такие как больше (`>`), меньше (`<`), меньше или равно (`=<`), больше или равно (`>=`), нестрогое равенство (`==`), строгое равенство (`=:=`), неравенство (`=/=`). Повводите в интерпретатор различные варианты сравнений и попытайтесь понять, по каким правилам сравниваются те или иные термы. Например:
 - `atom1 > atom2.`
 - `atom10 < atom2.`
 - `#{a => 0} < #{a => 1}.`
 - `#{a => 1} < #{a => 0, b => 0}.`
 - `{a, 1, 0} > {a, 0, 0}`.

Объясните результат каждого сравнения. Попробуйте сравнить между собой термы разных типов.

#### 1.4. Atoms, erlang shell
 - Какие атомы нельзя использовать?
 - В чем отличие строго равенства от нестрогого?
 - Как заставить интерпретатор "забыть" значение какой-либо переменной? А как заставить "забыть" все связывания?

#### 1.5. Lists/binary comprehensions
 - Напишите LC, который выдаст декартово умножение двух списков.
 - Имеется список вида - [[1,2,3], [4,5,6], [7,8,9]]. С помощью какого LC мы можем получить плоский список?
 - Имеется список словарей вида:

```erlang
Dicts = [
    #{
        tags => [awesome, erlang],
    },
    #{
        tags => [simple_tag]
    },
    #{
        tags => [just_atom, 'I am ok']
    }
]
```

Какой list comprehension выдаст список вида: `[awesome, erlang, simple_tag, just_atom, 'I am ok']` ?.

 - Попробуйте поменять порядок генераторов в полученных LC. Объясните результат.
 - Имеется следующий список:
```erlang
MixedList = [
    john,
    doe,
    {age, 19},
    {height, 182},
    {weight, 72},
    london,
    britain
].
```
   - С помощью какого LC можно получить список вида? (см. ниже):
```erlang
 [
    {age, 19},
    {height, 182},
    {weight, 72}
 ]
```
   - Какой LC выдаст список, в котором только атомы `[john, doe, london, britain]` ?

 - Имеется список объектов, представляющих прямоугольники на плоскости, следующего вида:
```erlang
Shapes = [
    {{0, 0}, {10, 10}},
    {{0, 1}, {2, 30}},
    {{30, 31}, {40, 41}},
    {{32, 56}, {5, 9}}
]
```
Написать LC, результатом которого будет список прямоугольников с площадью меньше N.
 - Написать binary comprehension, который сериализует список прямоугольникаов в бинарное представление.
 - Напишите list comprehension, распакует бинарную строку в список, эквивалентный списку Shapes.

### Неясность с [term|term]:
В машине Erlang есть одна неясная деталь. Рассмотрим набор следующих выражений:
```erlang
1> [atom|atom].
[atom|atom]
2> [Head|Tail] = [atom] ++ atom.
[atom|atom]
3> Tail.
atom
4> Head.
atom
```
Явное противоречение: тип  "список" рекурсивно определяется как [голова | хвост]. "голова" может являться любым термом, но "хвост" должен быть списком. В приведенном выше примере этого не наблюдается!
Что это - "бага" или "фича" - не очень ясно, но следует об этом помнить, иногда такое весьма неочевидное поведение может привести к веселым неожиданностям. При этом следует отметить, что данная операция с такими аргументами  некоммутативна:
```erlang
5> atom ++ [atom].
** exception error: bad argument
     in operator  ++/2
             called as atom ++ [atom]
```

### Дополнение про типы данных:
В этом блоке мы перечислили базовые типы данных, но помимо них существуют еще и служебные типы данных. Например, идентификатор процесса - pid, (об этом вы узнаете из следующих блоков), reference - уникальный идентификатор. Также существует и функциональный тип данных, который указывает на то, что функции являются объектами первого класса - они могут быть значениями, их можно передавать. Это лямбды и ссылки на функции.

## Модули, функции, базовые управляющие конструкции
В Erlang модуль - это одна из основных рабочих единиц программы. В рамках модулей мы можем вводить определения функций, экспортировать их, импортировать другие функции из других модулей, использовать внутренние функции. Каждый модуль имеет достаточно просту структуру. В этом разделе вы также узнаете про базовые управляющие конструкции - `if`, `case`, `guards`.
### Материалы для изучения:
 - Joe Armstrong, Programming in Erlang, chapter 3, pages 43 - 48.
 - [Введение в модули (eng)](http://learnyousomeerlang.com/modules)
 - [Функции (eng)](http://learnyousomeerlang.com/syntax-in-functions)

### Вопросы
 - Какой командой оболочки можно скомпилировать модуль?
 - Как посмотреть информацию о скомпилированном модуле? Какие есть способы?
 - Как получить список экспортируемых модулем функций и сохранить его в переменную?

### Упражнения
#### 1.6. Булевые операции
 - Напишите модуль bool.erl и определите в нём логические операции
   - `b_not/1`
   - `b_and/2`
   - `b_or/2`
   - `b_xor/2`

на атомах true и false. При определении функций пользуйтесь сопоставлением с образцом, а не встроенными функциями and, or и not. Ниже приведены примеры использования модуля в интерпретаторе:
```erlang
1> c(bool).
{ok,bool}
2> bool:b_not(true).
false
3> bool:b_and(true, true).
true
4> bool:b_and(true, false).
false
5> bool:b_or(true, false).
true
6> bool:b_or(false, false).
false
7> bool:b_or(false, true). 
true
8> bool:b_not(bool:b_or(false, true)).
false
9> bool:b_xor(true, false).
true
10> bool:b_xor(true, true). 
false
```

#### 1.7.  Работа со списками.
 - Напишите функцию `create/1`, которая на вход принимает число N и возвращает список вида `[1, 2,..., N -1, N]`.
 - Напишите функцию, которая также принимает число N, но возвращает список вида `[N, N-1, ..., 2,1]`.
 - Напишите функцию, которая распечатывает все числа от 1 до N.
 - Напишите функцию, которая распечатывает все нечётные числа от 1 до N.
 - Напишите функцию, которая принимает на вход список целых чисел и одно целое число, а возвращает список всех элементов списка, которые меньше либо равны числу, переданному вторым аргументом. Пример: `filter([1, 2, 3, 4, 5], 3) => [1,2,3].`
 - Напишите функцию, которая переворачивает список. Пример: `reverse([1,2,3]) => [3,2,1].`
 - Напишите функцию, которая преобразует список списков в один список, соединяя все списки-элементы. Пример: `concatenate([[1,2,3], [], [4, five]]) => [1,2,3,4,five].`. Подсказка: вам придётся написать вспомогательную функцию и выполнить объединение списка в несколько действий.
 - Напишите функцию, которая по списку вложенных списков строит линейный список. Пример: `flatten([[1, [2 , [3] , [] ], [[[4]]], [5,6]]) => [1,2,3,4,5,6].`. Подсказка: воспользуйтесь функцией concatenate.
 - Напишите функцию, которая принимает на вход последовательность нуклеотидов ДНК и выдает комплементарную ей цепочку нуклеотидов РНК. Траскрипция происходит путем замены нуклеотидов в исходной цепочке ДНК на парные им нуклеотиды, входящие в цепочку РНК. ДНК содержит четыре нуклеотида: `A` - аденин, `С` - цитозин, `G` - гуанин, `T` - тимин. В РНК содержатся следующие нуклеотиды: `A` - аденин, `С` - цитозин, `G` - гуанин, `U` - урацил. Словарь замены:
   - `G` -> `C`
   - `C` -> `G`
   - `T` -> `A`
   - `A` -> `U`
   Функция должна принимать либо список вида `"AAGGUU"` либо список вида `[a, a, g, g, u, u]`.
 - Напишите функцию, которая из заданной цепочки РНК/ДНК вырезает заданную последовательность из трех нуклеотидов. Пример: `cut_rdna("AAGGTT", "AGG")  => "ATT"`.

#### 1.8. База данных
Напишите модуль db.erl, создающий базу данных, в которой можно хранить, записывать и удалять элементы.
Функция `destroy/1` удаляет базу данных. Сборщик мусора выполнит всю работу за вас. Но в том случае,
если база хранится в файле, при вызове функции `destroy` вам придётся удалить этот файл. Функция `destroy`
включена для полноты интерфейса. При выполнении этого упражнения функциями из модулей *[lists](http://erlang.org/doc/man/lists.html)*, *[proplists](http://erlang.org/doc/man/proplists.html)*, *[dict](http://erlang.org/doc/man/dict.html)* пользоваться нельзя. Все рекурсивные функции должны быть написаны вами. Подсказка: используйте списки и кортежи в качестве основного типа данных. При тестировании помните, что все переменные могут связываться со значением только один раз.

Интерфейс:
```erlang
db:new() -> Db.
db:destroy(Db) -> ok.
db:write(Key, Element, Db) -> NewDb.
db:delete(Key, Db) -> NewDb.
db:read(Key, Db) -> {ok, Element} | {error, instance}.
db:match(Element, Db) -> [Keyl, ..., KeyN].
```

Пример использования в интерпретаторе:
```erlang
1> c(db).
{ok,db}
2> Db = db:new().
[]
3> Dbl = db:write(francesco, london, Db).
[{francesco,london}]
4> Db2 = db:write(lelle, 'Stockholm', Dbl).
[{lelle,'Stockholm'},{francesco,london}]
5> db:read(francesco, Db2).
{ok,london}
6> Db3 = db:write(joern, 'Stockholm', Db2).
[{joern,'Stockholm'}, {lelle,'Stockholm'}, {francesco,london}]
7> db:read(ola, Db3).
{error,instance}
8> db:match('Stockholm', Db3).
[joern,lelle]
9> Db4 = db:delete(lelle, Db3).
[{joern,'Stockholm'}, {francesco,london}]
10> db:match('Stockholm', Db4).
[joern]
```

#### 1.9.\* Простой вычислитель (задача повышенной сложности)
Постройте небольшой вычислитель арифметических выражений.
Начнём с таких выражений: `((2+3)-4)`, `4`, `~((2*3)+(3*4))`.
Простановка скобок в выражениях обязательна, и (`~`) означает унарный минус.
Для начала напишите функцию разбора таких выражений, которая будет возвращать
выражение, кодирующее в типах Erlang данное выражение.
К примеру,

`{minus, {plus, {num, 2}, {num, 3}}, {num, 4}}`

означает `((2 + 3)-4)`.

Назовём такие выражения exps. Определите несколько функций:

 * вычислитель, который принимает выражение и возвращает его значение;
 * принтер, который преобразует выражение в строку;
 * компилятор, который преобразует выражение в последовательность действий стек-машины;
 * симулятор, который проводит вычисление последовательности действий стек-машины;
 * преобразователь, который упрощает выражение, так чтобы `0 * е` заменялось на 0 и `1 * е` заменялось на е и многие другие правила преобразования выражений.

Также вы можете добавить условные выражения:

```
if ((2+3)-4) then 4 else ~((2*3)+(3*4))
```

Условные выражения возвращают значение после then, если значение выражения после if равно нулю, и значение выражения после else в противном случае.

Также вы можете добавить локальные определения:

```
let с = ((2+3)-4) in ~((2*с)+(3*4))
```

Или вы можете добавить переменные, которые можно определять и затем использовать во всех последующих выражениях.
Обратите внимание на то, как будут изменятся уже определённые функции обработки выражений при добавлении новых конструкций.
